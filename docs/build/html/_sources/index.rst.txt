Date Generator – Design Documentation
=====================================

Overview
--------

This project is a **design-only** midterm for a romantic or platonic date generator.

The goal is to show a clear architecture and use of design patterns without fully
implemented business logic or real external API calls.

The generator is intended to:

* Ask about user preferences (romantic vs platonic, indoor vs outdoor).
* Respect budget tiers (for example: under \$20, \$20–40, \$40–70, etc.).
* Use a location string and, later, mapping services.
* Optionally consider weather for outdoor plans.
* Assemble a short itinerary of activities that fits the constraints.

For the midterm, the focus is on structure and patterns, not on a completed application.

Domain Model
------------

The main domain concepts are:

* ``Activity`` – abstract base for things to do (restaurant outings, park walks,
  concerts, museums). Implemented in ``src/activities/``.
* ``Itinerary`` – a composite object representing a full date plan, made up of
  a sequence of activities and a total estimated cost.
* ``ItineraryAssembler`` – a small builder that constructs an ``Itinerary`` one
  activity at a time.

Together these implement a **Composite** + **Builder** style design for plans.

Core Design Patterns
--------------------

This project intentionally showcases several patterns:

* **Strategy**

  * ``ScoringPolicy`` in ``src/core/scoring.py`` defines how a set of activities
    is scored.
  * Concrete strategies (such as a budget-focused policy) allow different
    ranking rules without changing the planner.

* **Template Method**

  * ``PlanGenerator`` in ``src/core/plan_generator.py`` defines the high-level
    workflow for building a plan: gather candidates, apply constraints, score,
    and assemble an itinerary.
  * Helper methods can be overridden in subclasses for special behaviors.

* **Composite and Builder**

  * ``Itinerary`` and ``Activity`` form a Composite: an itinerary is a collection
    of activities but can be treated as a single object.
  * ``ItineraryAssembler`` acts as a simple Builder that incrementally constructs
    a valid itinerary.

* **Adapter (and simple Factory Method)**

  * ``WeatherProvider``, ``MapsProvider``, and ``PlacesProvider`` in
    ``src/providers/`` act as adapter interfaces over future external services.
  * ``StubPlaces`` returns concrete activity objects and demonstrates a
    factory-style creation of domain objects without exposing details to the
    planner.

* **Constraints Abstraction**

  * ``Constraint`` and concrete classes like ``BudgetCeiling`` in
    ``src/core/constraints.py`` express rules that filter out invalid activities.
  * Multiple constraints can be combined without changing the planner itself.

Modules
-------

The code is organized as follows:

* ``src/activities/`` – Abstract activity base class and concrete activities.
* ``src/core/`` – Core planning elements (constraints, scoring, itinerary,
  plan generator).
* ``src/providers/`` – Adapter interfaces and stub implementations for weather,
  maps, and places.
* ``src/explain/`` – ``ExplanationEngine`` for generating human-readable
  explanations.
* ``src/export/`` – Placeholder for export logic (for example, PDF export).

Future Work
-----------

Future improvements could include:

* Implementing richer ``ScoringPolicy`` strategies (romance-focused,
  accessibility-focused, weather-aware).
* Integrating real external APIs for weather, mapping, and places.
* Expanding the catalog of activities to cover more types of dates.
* Building a user interface on top of the current design.


